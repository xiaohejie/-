### 面向对象设计模式

#### 1、依赖倒置原则（DIP）

* 高层模块（稳定）不应该依赖于底层模块（变化），二者都应该依赖于抽象（稳定）；
* 抽象（稳定）不应该依赖于实现细节（变化），实现细节应该依赖于抽象（稳定）。

#### 2、开放封闭原则（OCP）

* 对扩展开放，对更改封闭；
* 类模块应该是可扩展的，但是不可修改。

#### 3、单一职责原则（SRP）

* 一个类应该仅有一个引起它变化的原因；
* 变化的方向隐含这类的责任。

#### 4、iskov替换原则（LSP）

* 子类必须能够替换它们的基类（IS-A）；
* 继承表达类型抽象

#### 5、接口隔离原则（ISP）

* 不应该强迫客户程序依赖他们不用的方法；
* 接口应该小而完备。

#### 6、优先使用对象组合，而不是类继承

* 类继承通常为“白箱复用”，对象组合通常为“黑箱复用”；
* 继承在某种程度上破坏了封装性，子类父类耦合度高
* 而对象组合则只要求被组合的对象具有良好定义的接口，耦合度低。

#### 7、封装变化点

* 使用封装来创建对象之间的分界层，让设计者可以在分界一侧进行修改，而不会对另一侧产生不良的影响，从而实现层次间的松耦合。

#### 8、针对接口编程，而不是针对实现编程

* 不将变量类型声明为某个特定的具体类，而是声明为某个接口；
* 客户程序无需获知对象的具体类型，只需要知道所具有的接口。
* 减少系统中的各部分依赖关系，从而实现“高内聚，低耦合”的类型涉及方案。

### “组件协作”模式

##### 模板方法（Template Method）

* 定义一个操作中的算法的骨架（稳定），而将一些延迟（变化）到子类中。Template Method使得子类可以不改变（复用）一个算法的结构即可重定义（override重写）该算法的某些特定步骤。

##### Strategy (策略模式)

* 定义一系列算法，把它们一个个封装起来，并且使它们可以互相替换（变化）。该模式使得算法可独立于使用它们的客户程序（稳定）而变化（扩展，子类化）
* Strategy及其子类为组件提供了一系列可重用的算法，从而使得类型在运行时方便的根据需要在各个算法之间进行切换
* Strategy模式提供了用条件判断语句以外的另一种选择，消除条件判断语句，就是在解耦合。含有许多条件判断语句的代码通常需要Strategy模式
* 如果Strategy对象没有实例变量，那么各个上下文可以共享同一个Strategy对象，从而节省对象开销。

##### Event（事件模式）/Observer（观察者模式）

* 定义对象间的一种一对多（变化）的依赖关系，以便当一个对象（Subject）的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。
* 使用面向对象的抽象，Observer模式是得我们可以独立的改变目标与观察者，从而使二者之间的依赖关系达致松耦合。
* 目标发送通知时，无需指定观察者。通知（可以携带通知信息作为参数）会自动传播。
* 观察者自己决定是否需要订阅通知，目标对象对此一无所知。
* Observer模式是基于事件的UI框架中非常实用的设计模式，也是MVC模式的一个重要组成部分。

### “单一职责”模式

​		在软件组件的设计中，如果有责任划分的不清晰，使用继承得到的结果往往是随着需求的变化，子类急剧膨胀，同时充斥着重复代码。这时候的关键是划清责任

##### Decorator（装饰模式）

* 在某些情况下我们可能会“过度的使用继承来扩展对象的功能”，由于继承为类型引入的静态特质，使得这种扩展方式缺乏灵活性；并且随着子类的增多（扩展功能的增多），各种子类的组合（扩展功能的组合）会导致更多子类的膨胀。
* 动态（组合）地给一个对象增加一些额外的职责，就增加功能而言，Decorator模式比生成子类（继承）更为灵活（消除重复代码和减少子类个数）
* 要点总结：
  * 通过采用组合而非继承的手法，Decorator模式实现了在**运行时**动态扩展对象功能的能力，而且可以根据需要扩展多个功能。避免了使用继承带来的“灵活性差”和“多子类衍生问题”。
  * Decorator类在接口上表现为is-a Component的继承关系，即Decorator类继承了Component类所具有的接口。但在实现上又表现为has- a Component的组合关系，即Decorator类又使用了另外的Component类。
  * Decorator模式的目的并非解决“多子类衍生的多继承”问题，Decorator模式应用的要点在于解决“主体类在多个方向上的扩展功能”--------是为“装饰”的含义。

##### Bridge（桥模式）

* 由于某些类型的固有的实现逻辑，使得他们具有两个变化的维度，乃至多个维度的变化。
* 模式定义：
  * 将抽象部分（业务功能）与实现部分（平台分离），使得他们可以独立的变化。

* 要点总结：
  * Bridge模式使用“对象间的组合关系”解耦了抽象和实现之间的固有的绑定关系，使得抽象和实现可以沿着各自的维度变化。所谓抽象和实现沿着各自维度变化，即“子类化他们”。
  * Bridge模式有时候类似于多继承方案，但是多继承方案往往会违背单一继承原则（即一个类只有一个变化的原因），复用性比较差。Bridge模式是比多继承方案更好地解决方法；
  * Bridge模式的应用一般在“两个非常前的变化维度”，有时一个类也也有多余两个的变化维度，这是可以使用Bridge的扩展模式。

### “对象创建”模式

​		通过“对象创建”模式绕开new。来避免对象创建（new）过程中所导致的紧耦合（依赖具体类），从而支持对象创建的稳定。它是接口抽象之后的第一步工作。

##### Factory Method

* 模式定义：
  * 定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method使得一个类的实例化延迟（目的：解耦、手段：虚函数）到子类。
* 要点总结：
  * Factory Method模式常用于隔离类对象的使用者和具体类型之间的耦合关系。面对一个经常变化的具体类型，紧耦合关系（new）会导致软件的脆弱。
  * Factory Method模式通过面向对象的手法，将所要创建的具体对象工作延迟到子类，从而实现一种扩展（而非更改）的策略，较好地解决了这种紧耦合关系。
  * Factory Method模式解决了“单个对象”地需求变化。缺点在于要求创建方法/参数相同。

##### Abstract Factory（抽象工厂）

* 在软件系统中，经常面临着“一系列相互依赖的对象”的创建工作；同时，由于需求的变化，往往存在更多系列对象的创建工作。
* 模式定义：
  * 提供一个接口，让该接口负责一系列“相关或相互依赖的对象”，无需指定他们具体的类。
* 要点总结：
  * 如果没有应对“多系列对象构建”的需求变化，则完全没必要使用Abstract Factory模式，这时候可以使用简单的工厂；
  * “系列对象”指的是在某一特定系列下的对象之间有相互依赖、或作用的关系。不同系列的对象之间不能相互依赖；
  * Abstract Factory模式主要在于应对“新系列”的需求变动。其缺点在于难以应对“新对象的”需求变动。

##### Prototype（原型模式）

* 在软件系统中，经常面临这系统“某些结构复杂的对象“的创建工作；由于需求的变化，这些对象经常面临着剧烈的变化，但是他们却拥有比较稳定一致的接口。
* 模式定义：
  * 使用原型实例指定创建对象的种类，然后通过拷贝这些原型来创建新的对象。
* 要点总结：
  * Prototype模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，他同样要求这些“易变类”拥有“稳定的接口”；
  * Prototype模式对于“如何创建易变类的实体对象”采用“原型clone”的方法来做，它使得我们可以非常灵活的创建“拥有某些稳定接口”的新对象--------所需工作仅仅是注册一个新类的对象（即原型），然后在任何需要的地方Clone；
  * Prototype模式中的Clone方法可以利用某些框架中的序列化来实现深拷贝。

##### Builder （构建器）

* 在软件系统中，有时候面临着“一个复杂对象”的创建工作，其通常有各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着**剧烈的变化**，但是由于将他们组合在一起的算法却**相对稳定**。
* 模式定义：
  * 将一个复杂对象的构建与其表示相分离，使得同样的构建过程（稳定）可以创建不同的表示（变化）。

* 要点总结：
  * Builder模式主要用于“分步骤构建一个复杂的对象”。在这其中“分步骤”是一个稳定的算法，而复杂对象的各个部分则经常变化。
  * 变化点在哪里，封装在哪里--------Builder模式主要在于应对”复杂对象各个部分“的频繁需求变动。其缺点在于难以应对”分布构建算法“的需求变动。
  * 在Builder模式中，要注意不同语言中构造器调用虚函数的差别，c++中是静态调用，所以不能在构造器中使用。

### “对象性能”模式

面向对象很好地解决了“抽象“的问题，但是必不可免的要付出一定的代价。对于通常情况来讲，面向对象的成本大都可以忽略不计。但是某些情况，面向对象所带来的成本必须谨慎处理。

##### Singleton（单件模式）

* 在软件系统中，经常有这样一些特殊的类，必须保证他们在系统中只存在一个实例，才能确保他们的逻辑正确性以及良好的效率。
* 模式定义：
  * 保证一个类仅有一个实例，并提供一个该实例的全局访问点。
* 要点总结：
  * Singleton模式中的实例构造器可以设置为protected以允许子类派生；
  * Singleton内模式一般不要支持拷贝构造函数和Clone接口，因为这有可能导致多个对象实例，与Singleton模式的初衷违背。
  * 如何实现多线程环境下安全的Singleton？注意对双检查锁的正确实现。

##### Flyweight（享元模式）

* 在软件系统中采用纯粹对象方案的问题在于大量细粒度的对象会很快充斥在系统中，从而带来很高的运行时代价——主要是指内存需求方面的代价。
* 模式定义：
  * 运用共享模式有效的支持大量细粒度的对象。

* 要点总结：
  * 面向对象很好的解决了抽象性问题，但是作为一个运行在机器中的程序实体，我们需要考虑到对象的代价问题。Flyweight主要解决面向对象的代价问题，一般不触及面向对象的抽象性问题。
  * Flyweight采用对象共享的做法来降低系统中对象的个数，从而降低细粒度对象给系统带来的内存压力。在具体实现方面，要注意对象状态的处理。
  * 对象的数量太大而导致对象内存开销加大————什么样的数量才算大？这需要我们仔细的根据应用情况进行评估，而不能凭空臆断。

### “接口隔离”模式

​		在组件构建过程中，某些接口之间的依赖常常会带来很多问题，甚至根本无法实现。采用添加一层间接（稳定）接口，来隔离本来互相紧密关联的接口是一种常见的方案。

##### Facade（门面模式）

* 模式定义：
  * 为子系统的一组接口提供一个一致稳定的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用（复用）。
* 要点总结：
  * 从客户西程序的角度来看，Facade模式简化了整个组件系统的接口，对于组件内部与外部客户程序来说，达到了一种”解耦“的效果——内部子系统的任何变化不会影响到Facade接口的变化。
  * Facade设计模式更注重从架构的层次去看整个系统，而不是单个类的层次。Facade很多时候更是一种架构设计模式。
  * Facade设计模式并非一个集装箱，可以任意的放进任何多个对象。Facade模式中组件的内部应该是“相互耦合关系比较大的一系列组件”，而不是一个简单的功能集合。

##### Proxy（代理模式）

* 在面向对象系统中，有些对象由于某种原因（比如对象创建的开销很大，或者某些操作需要安全控制，或者需要进程外的访问等）直接访问会给使用者、或者系统结构带来很多麻烦。
* 如何在不是去透明操作对象的同时来管理/控制这些对象特有的复杂性？增加一层间接层是软件开发中常见的解决方式。
* 模式定义：
  * 为其他对象提供一种代理以控制（隔离，使用接口）对这个对象的访问。
* 要点总结：
  * “增加一层间接层”是软件系统中许多复杂问题的一种常见解决方法。在面向对象系统中，直接使用某些对象会带来很多问题，作为间接层的Proxy对象便是解决这一问题的常用手段；
  * 具体Proxy设计模式的实现方法，实现粒度都相差很大，有些可能对单个对象做细粒度的控制，如copy-on-write技术，有些可能对组件库模块提供抽象代理层，在架构层次对对象做Proxy；
  * Proxy并不一定要求保持接口完整一致性，只要能实现间接控制，有时候损及一些透明性是可以接受的。 

##### Adapter（适配器）

* 在软件系统中，由于应用环境的变化，常常需要将“一些现存的对象”放在新的环境中应用，但是新环境要求的接口是这些现存对象所不满足的。
* 如何应对这种“迁移的变化”？如何既能利用现有对象的良好实现，同时又能满足新的应用环境所要求的接口？
* 模式定义：
  * 将一个类的接口转换成客户希望的另一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
* 要点总结：
  * Adapter模式主要用于“希望复用一些现存的类，但是接口又与复用环境要求不一致的情况”，在遗留代码复用、类库迁移等方面非常有用。
  * GoF23定义了两种Adapter模式的实现结构：对象适配器和类适配器。但是类适配器采用“多继承“的实现方式，一般不推荐使用。对象适配器采用”对象组合“的方式，更符合松耦合精神；
  * Adapter模式可以实现的非常灵活，不必拘泥于Cof23中定义的两种结构。例如：完全可以将Adapter模式中的“现存对象”作为新的接口方法参数，来达到适配的目的。

##### Mediator（中介者）

* 在软件构建过程中，经常会出现**多个对象互相关联交互**的情况，对象之间常常会维持一种复杂的引用关系，如果遇到一些需求的更改，这种直接的引用关系将面临不断地变化。
* 在这种情况下，我们可使用一个“**中介对象**”来管理对象间的关联关系，避免相互交互的对象之间的紧耦合引用关系，从而更好的抵御变化。
* 模式定义：
  * 用一个“中介对象”来封装（封装变化）一系列的对象交互。中介者使各对象不需要显示的相互引用（编译时依赖---->运行时依赖），从而使其耦合松散（管理变化），而且可以独立的改变他们之间的交互。

* 要点总结：
  * 将多个对象间复杂的关联关系解耦，Mediator模式将多个对象间的控制逻辑进行集中管理，变“多个对象互相关联”为“多个对象和一个中介者关联”，简化了系统的维护，抵御了可能的变化。
  * 随着控制逻辑的复杂化，Mediator具体对象的实现可能相当复杂。这时候可以对Mediator对象进行分解处理。
  * Facade模式是解耦系统间（单向）的对象关联关系；Mediator模式是解耦系统内各个对象之间（双向）的关联关系。

### “状态变化”模式

​		在组件构建过程中，某些对象的状态经常面临变化，如何对这些变化进行有效的管理？同时又维持高层模块的稳定？“状态变化”模式为这一问题提供了一种解决方案。

##### State（状态模式）

​	（对比Strage模式）

​		在软件构建过程中，某些对象的状态如果改变，其行为也会随之而发生变化，比如文档处于只读状态，其支持的行为和读写状态支持的行为就可能完全不同。

​		如何在运行时根据对象的状态来透明的更改对象的行为？而不会为对象操作和状态转化之间引入紧耦合？

* 模式定义：
  * 允许一个对象在其内部状态改变时改变它的行为。从而使得对象看起来似乎修改了其行为。

* 要点总结：
  * State模式将**所有与一个特定状态相关的行为**都放入一个State的子类对象中，在对象状态切换时，**切换相应的对象**；但**同时维持State的接口**，这样实现了具体操作与状态转换之间的解耦。
  * 为不同的状态引入不同的对象使得状态转换变得更加明确，而且可以保证不会出现状态不一致的情况，因为转换是原子性的——即要么彻底转换过来，要么不转换。
  * 如果State对象没有实例变量，那么各个上下文可以共享同一个State对象，从而节省对象开销。

##### Memento（备忘录）

​		在软件构建过程中，某些对象的状态在转换过程中，可能由于某种需要，要求程序能够回溯到对象之前处于某个点时的状态。如果使用一些公有接口来让其他对象得到对象的状态，变回暴露对象的实现细节，

​		如何实现对象状态的良好保存与恢复？但同时又不会因此而破坏对象本身的封装性。

* 模式定义：
  * 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可以将该对象恢复到原先保存的状态。

* 要点总结：
  * 备忘录（Memento）存储原发器（Originator）对象的内部状态，在需要时恢复原发器状态。
  * Memento模式的核心是信息隐藏，即Originator需要向外接隐藏信息，保持其封装性。但同时又需要将状态保持到外界（Memento）；
  * 由于现代语言（如C#、Java等）运行时都具有相当的对象序列化支持，因此往往采用效率较高、又较容易正确实现的序列化方案来实现Memento模式。

### “数据结构”模式

​		常常有一些特定组件在内部具有特定的数据结构，如果让客户程序依赖这些特定的数据结构，将极大的破坏组件的复用。这时候，将这些特定的数据结构封装在内部，在外部提供统一的接口，来实现与特定数据结构无关的访问，是一种行之有效的解决方案。

##### Composite（组合模式）

​		在软件在某些情况下，客户代码过多的依赖与对象容器复杂的内部实现结构，对象容器内部实现结构（而非抽象接口）的变化将引起客户代码的频繁变化，带来了代码的维护性、扩展性等弊端。

​		如何将“客户代码与复杂的对象容器结构”解耦？让对象容器自己来实现自身的复杂结构，从而使得客户代码就像处理简单对象一样来处理复杂的对象容器？

* 模式定义：
  * 将对象组合成**树形结构**以表示“部分-整体”的层次结构。Composite使得用户对单个对象和组合对象的使用具有一致性（稳定）。

* 要点总结：
  * Composite模式采用树形结构来实现普遍存在的对象容器，从而将“一对多”的关系转化为“一对一”的关系，使得客户代码可以一致的（复用）处理对象和对象容器，无需关心处理的是单个对象，还是组合的对象容器。
  * 将“客户代码与复杂的对象容器结构”解耦是Composite的核心思想，解耦之后，客户代码将与纯粹的抽象接口——而非对象容器的内部实现结构——发生依赖，从而更能“应对变化”。
  * Composite模式在具体实现中，可以让父对象中的子对象反向回溯；如果父对象有频繁的遍历需求，可以使用缓存技巧来改善效率。

##### Iterator（迭代器）

**（过时）**

​		在软件构建过程中，集合对象内部结构常常变化各异。但对于这些集合对象，我们希望在不暴露其内部结构的同时，可以让外部客户代码透明的访问其中包含的元素；同时这种“透明遍历”也为“同一种算法在多种集合对象上进行操作”提供了可能。

​		使用面向对象技术将这种遍历机制抽象为“迭代器对象”为“应对变化中的集合对象”提供了优雅的方式。

* 模式定义：
  * 提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露（稳定）该对象的内部表示。

* 要点总结：
  * 迭代抽象：访问一个聚合对象的内容而无需暴露它的内部表示；
  * ·迭代多态：为遍历不同的集合结构提供一个统一的接口，从而支持同样的算法在不同的集合结构上进行操作；
  * 迭代器的健壮性考虑：遍历的同时更改迭代器所在的集合结构，会导致问题。

##### Chain of Resposibility（职责链）

**（过时）**

​		在软件构建过程中，一个请求可能被多个对象处理，但是每个请求在运行时只能有一个接受者，如果显示指定，将必不可少的带来请求发送者与接受者的紧耦合。

​		如何使请求的发送者不需要指定具体的接受者？让请求的接受者自己在运行时处理请求，从而是两者解耦。

* 模式定义：
  * 使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。将**这些对象连成一条链**，并沿着这条链传递请求，直到有一个对象处理它为止。

* 要点总结：
  * Chain of Resposibility模式的应用场合在于“一个请求可能有多个接受者，但是最后真正的接受者只有一个”，这时候请求发送者与接受者的耦合有可能出现“变化脆弱的症状”，职责链的目的在于将二者解耦，从而更好地应对变化。
  * 应用了Chain of Resposibility模式后，对象的职责分派将更具灵活性。我们可以在运行时动态添加/修改请求的处理职责。
  * 如果请求传递到职责链的末尾仍得不到处理，应该有一个合理的缺省机制。这也是每一个接受对象的责任，而不是发出请求的对象的责任。

### ”行为变化“模式

​		在组件的构建过程中，组件行为的变化经常导致组件本身剧烈的变化。**“行为变化”模式将组件的行为和组件本身进行解耦**，从而支持组件行为的变化，实现两者的淞耦合；

##### Command（命令模式）

​		在组件构建过程中，“行为请求者”与“行为实现者”通常呈现一种“紧耦合”。 但在某些场合——比如需要对行为进行“记录、撤销/重（undo/redo）、事物”等处理，这种无法抵御变化的紧耦合是不适合的。

​		在这种情况下，如何将“行为请求者”与”行为实现者“解耦？将一组行为抽象为对象，可以实现二者的松耦合。

* 模式定义：
  * 将一个请求（行为）封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或请求日志，以及支持可撤销的操作。

* 要点总结：
  * Command模式的根本目的在于**将“行为请求者”与“行为实现者”解耦**，在面向对象的语言中，常见的实现手段是“**将行为抽象为对象**”。
  * 实现Command接口的具体命令对象ConcreteCommand有时候根据需要可能会保存一些额外的状态信息。通过使用Composite模式，可以将多个“命令”封装为一个“复合命令”MacroCommand。
  * Command模式与C++中的函数对象有些类似。但两者定义行为接口的规范有所区别：Command以面向对象中的“接口-实现”来定义行为接口规范，更严格，但会损失性能；C++函数对象以函数签名来定义行为接口规范，更灵活，性能更高。

##### Visitor（访问器）

​		在软件构建过程中，由于需求的改变，某些类层次结构中常常需要增加新的行为（方法），如果直接在基类中做这样的更改，将会给子类带来很繁重的变更负担，甚至破坏原有设计。

​		如何在不更改类层次结构的前提下，在运行是根据需要透明的为类层次结构上的各个类动态添加新的操作，从而避免上述问题？

* 模式定义：
  * 表示一个作用于某对象结构中的各元素的操作。使得可以在不改变（稳定）各元素的类的前提下定义（扩展）作用于这些元素的心操作（变化）。

* 要点总结：
  * Visitor模式通过所谓的双重分发（double dispatch）来实现在不更改（不添加新的操作-编译时）Element类层次结构的前提下，在运行时透明的为类层次结构上的各个类动态添加新的操作（支持变化）；
  * 所谓双重分发即Visitor模式中间包括了两个多态分发（注意其中的多态机制）：一个为accept方法的多态辨析；第二个为visitElementX方法的多态辨析。
  * Visitor模式的最大缺点在于扩展类的层次（增添新的Element子类），会导致Visitor类的改变。因此Visitor模式适用于“Element类层次结构稳定，而其中的操作却经常面临频繁改动”。